# 📅 A 10-Week Daily DSA Study Plan (90 Minutes/Day)

## <span style="color:#4285F4">Week 1: 🧪 JavaScript & Complexity Foundations (Phase 1)</span>

### Day 1: 💻 JS Fundamentals Review
*   **Theory** *(30 min)*: 📚 Revisit Variables, Functions, Scoping, and ES6+ features from your syllabus.
*   **Practice** *(60 min)*: ✍️ Solve 5-10 basic JavaScript challenges on HackerRank or CodeWars focusing on array/string methods.

### Day 2: 🗂️ JS Collections & Async
*   **Theory** *(30 min)*: 📚 Deep dive into Objects, `Map`, `Set`, and review the concepts of Closures and Promises.
*   **Practice** *(60 min)*: ✍️ Practice array and object manipulation problems on LeetCode.

### Day 3: ⏱️ Time Complexity
*   **Theory** *(30 min)*: 📚 Understand Big O, Big Θ, and Big Ω notations. Learn to analyze the complexity of simple loops and recursive functions.
*   **Practice** *(60 min)*: ✍️ Analyze the time complexity of code snippets. Use Visualgo to see performance differences.

### Day 4: 💾 Space Complexity
*   **Theory** *(30 min)*: 📚 Learn about Auxiliary Space vs. Input Space and what makes an algorithm "In-place".
*   **Practice** *(60 min)*: ✍️ Analyze the space complexity of the same code snippets from yesterday.

### Day 5: 🔢 Mathematical Concepts
*   **Theory** *(30 min)*: 📚 Study Prime Numbers (Sieve of Eratosthenes) and GCD/LCM.
*   **Practice** *(60 min)*: ✍️ Implement the Sieve of Eratosthenes and a function to calculate GCD.

### Day 6: 🎯 Practice & Review
*   **Practice** *(90 min)*: ✍️ Solve LeetCode "Easy" problems focusing on basic array manipulation and complexity analysis.

### Day 7: 🛌 Rest or Catch-up

---

## <span style="color:#34A853">Week 2: ⛓️ Arrays, Strings & Linked Lists (Phase 2)</span>

### Day 8: 👉 Array Technique: Two Pointers
*   **Theory** *(30 min)*: 📚 Understand the Two Pointer technique for problems like sorted array search and palindrome checks.
*   **Practice** *(60 min)*: ✍️ Solve `"Two Sum II"` and `"Valid Palindrome"` on LeetCode.

### Day 9: 🖼️ Array Technique: Sliding Window
*   **Theory** *(30 min)*: 📚 Learn the Sliding Window technique for subarray/substring problems.
*   **Practice** *(60 min)*: ✍️ Solve `"Best Time to Buy and Sell Stock"` and `"Longest Substring Without Repeating Characters"`.

### Day 10: ➕ Array Technique: Prefix Sum
*   **Theory** *(30 min)*: 📚 Understand the Prefix Sum concept for efficient range sum queries.
*   **Practice** *(60 min)*: ✍️ Solve `"Range Sum Query - Immutable"` on LeetCode.

### Day 11: 📜 String Operations
*   **Theory** *(30 min)*: 📚 Review string manipulations and get an introduction to pattern matching (e.g., brute-force).
*   **Practice** *(60 min)*: ✍️ Implement functions for finding substrings and checking for anagrams.

### Day 12: 🔗 Linked Lists (Singly)
*   **Theory** *(30 min)*: 📚 Learn what a Singly Linked List is. Implement a `Node` and `LinkedList` class with `insert` and `search`.
*   **Practice** *(60 min)*: ✍️ Add `delete` and `reverse` methods to your `LinkedList` class.

### Day 13: 🎯 Practice & Review
*   **Practice** *(90 min)*: ✍️ Solve 2-3 medium problems on arrays, strings, and linked lists.

### Day 14: 🛌 Rest or Catch-up

---

## <span style="color:#FBBC05">Week 3: 🥞 Stacks, Queues & Advanced Lists (Phase 3)</span>

### Day 15: 🥞 Stacks
*   **Theory** *(30 min)*: 📚 Understand the LIFO principle. Implement a Stack using both an Array and a Linked List.
*   **Practice** *(60 min)*: ✍️ Solve `"Valid Parentheses"` on LeetCode.

### Day 16: 🥞 Stack Problems
*   **Theory** *(30 min)*: 📚 Study applications like "Next Greater Element".
*   **Practice** *(60 min)*: ✍️ Solve `"Next Greater Element I"` and `"Min Stack"`.

### Day 17: 🚶 Queues
*   **Theory** *(30 min)*: 📚 Understand the FIFO principle. Implement a Queue using an Array and a Linked List.
*   **Practice** *(60 min)*: ✍️ Implement a Queue using two stacks.

### Day 18: 🔄 Queue Types
*   **Theory** *(30 min)*: 📚 Learn about Circular Queues and Deques (Double-Ended Queues).
*   **Practice** *(60 min)*: ✍️ Implement a basic Circular Queue.

### Day 19: 🔗 Linked Lists (Advanced)
*   **Theory** *(30 min)*: 📚 Learn Floyd's Tortoise and Hare algorithm for cycle detection.
*   **Practice** *(60 min)*: ✍️ Solve `"Linked List Cycle"` and `"Merge Two Sorted Lists"`.

### Day 20: 🎯 Practice & Review
*   **Practice** *(90 min)*: ✍️ Solve 2-3 medium problems combining stacks, queues, and linked lists.

### Day 21: 🛌 Rest or Catch-up

---

## <span style="color:#8A2BE2">Week 4: 🗄️ Hash Tables & Basic Sorting (Phase 3 & 4)</span>

### Day 22: 🔑 Hash Tables (Hash Maps)
*   **Theory** *(30 min)*: 📚 Understand hash functions, collision resolution, and the difference between `Map` and `Object` in JS.
*   **Practice** *(60 min)*: ✍️ Solve `"Two Sum"` (the classic) and `"Ransom Note"` using a `Map`.

### Day 23: 🔑 Hash Table Problems
*   **Theory** *(30 min)*: 📚 Look at problems involving frequency counting.
*   **Practice** *(60 min)*: ✍️ Solve `"Group Anagrams"` and `"Top K Frequent Elements"`.

### Day 24: 📊 Basic Sorting Algorithms
*   **Theory** *(30 min)*: 📚 Learn Bubble Sort, Selection Sort, and Insertion Sort. Understand their O(n²) complexity.
*   **Practice** *(60 min)*: ✍️ Implement all three from scratch.

### Day 25: 🔁 Recursion Fundamentals
*   **Theory** *(30 min)*: 📚 Understand the base case and recursive step. Trace a simple recursion like factorial.
*   **Practice** *(60 min)*: ✍️ Write recursive solutions for Factorial and Fibonacci.

### Day 26: 🔁 Recursion & Sorting
*   **Theory** *(30 min)*: 📚 Learn the concept of Divide and Conquer.
*   **Practice** *(60 min)*: ✍️ Use recursion to solve problems like "Reverse a String".

### Day 27: 🎯 Practice & Review
*   **Practice** *(90 min)*: ✍️ Solve problems that can be optimized with hash tables. Re-implement one of the basic sorting algorithms without looking.

### Day 28: 🛌 Rest or Catch-up

---

## <span style="color:#008000">Week 5: 🌲 Efficient Sorting & Introduction to Trees (Phase 4 & 3)</span>

### Day 29: 🌪️ Merge Sort
*   **Theory** *(30 min)*: 📚 Understand the "divide and conquer" strategy of Merge Sort.
*   **Practice** *(60 min)*: ✍️ Implement Merge Sort from scratch.

### Day 30: ⚡ Quick Sort
*   **Theory** *(30 min)*: 📚 Understand the pivot and partition logic of Quick Sort.
*   **Practice** *(60 min)*: ✍️ Implement Quick Sort from scratch.

### Day 31: 🌳 Introduction to Trees
*   **Theory** *(30 min)*: 📚 Learn tree terminology (root, child, parent, leaf, height, depth). Understand Binary Trees.
*   **Practice** *(60 min)*: ✍️ Implement a `TreeNode` class.

### Day 32: 🧭 Tree Traversal (DFS)
*   **Theory** *(30 min)*: 📚 Learn Pre-order, In-order, and Post-order traversals.
*   **Practice** *(60 min)*: ✍️ Implement all three DFS traversals recursively.

### Day 33: 🧭 Tree Traversal (BFS)
*   **Theory** *(30 min)*: 📚 Learn Level-order traversal using a Queue.
*   **Practice** *(60 min)*: ✍️ Implement BFS traversal for a binary tree.

### Day 34: 🎯 Practice & Review
*   **Practice** *(90 min)*: ✍️ Solve tree problems like `"Maximum Depth of Binary Tree"` and `"Invert Binary Tree"`.

### Day 35: 🛌 Rest or Catch-up

---

## <span style="color:#2E8B57">Week 6: 🌲 Advanced Trees (Phase 3)</span>

### Day 36: 🔍 Binary Search Trees (BST)
*   **Theory** *(30 min)*: 📚 Understand the properties of a BST.
*   **Practice** *(60 min)*: ✍️ Implement `insert` and `search` methods for a BST.

### Day 37: ✅ BST Validation & Deletion
*   **Theory** *(30 min)*: 📚 Learn how to validate if a tree is a BST. Understand the logic for deleting a node.
*   **Practice** *(60 min)*: ✍️ Solve `"Validate Binary Search Tree"`.

### Day 38: ⛰️ Heaps (Priority Queues)
*   **Theory** *(30 min)*: 📚 Understand the concept of Min-Heap and Max-Heap.
*   **Practice** *(60 min)*: ✍️ Implement a Min-Heap (or use a library) to solve `"Kth Largest Element in an Array"`.

### Day 39: ⛰️ Heap Sort
*   **Theory** *(30 min)*: 📚 Learn how a heap can be used for sorting.
*   **Practice** *(60 min)*: ✍️ Conceptually walk through Heap Sort. (Implementation is complex, focus on the idea).

### Day 40: 🔤 Tries
*   **Theory** *(30 min)*: 📚 Understand the structure of a Trie for efficient string prefix searching.
*   **Practice** *(60 min)*: ✍️ Implement a Trie with `insert` and `search` methods.

### Day 41: 🎯 Practice & Review
*   **Practice** *(90 min)*: ✍️ Solve 2-3 medium problems on BSTs, Heaps, and Tries.

### Day 42: 🛌 Rest or Catch-up

---

## <span style="color:#EA4335">Week 7: 🗺️ Backtracking & Introduction to Graphs (Phase 4 & 3)</span>

### Day 43: 🔙 Backtracking
*   **Theory** *(30 min)*: 📚 Deep dive into the backtracking template: choose, explore, un-choose.
*   **Practice** *(60 min)*: ✍️ Solve `"Subsets"`.

### Day 44: 🔙 Backtracking Problems
*   **Theory** *(30 min)*: 📚 Analyze the structure of permutation problems.
*   **Practice** *(60 min)*: ✍️ Solve `"Permutations"` and `"Combination Sum"`.

### Day 45: 🌐 Introduction to Graphs
*   **Theory** *(30 min)*: 📚 Learn graph terminology and representations (Adjacency List vs. Adjacency Matrix).
*   **Practice** *(60 min)*: ✍️ Build a graph representation in code from a given set of edges.

### Day 46: 🌐 Graph Traversal: BFS
*   **Theory** *(30 min)*: 📚 Apply BFS to graphs. Understand its use in finding the shortest path in unweighted graphs.
*   **Practice** *(60 min)*: ✍️ Implement BFS on your graph structure.

### Day 47: 🌐 Graph Traversal: DFS
*   **Theory** *(30 min)*: 📚 Apply DFS to graphs. Understand its use in exploring paths and detecting cycles.
*   **Practice** *(60 min)*: ✍️ Implement DFS (recursive and iterative) on your graph structure.

### Day 48: 🎯 Practice & Review
*   **Practice** *(90 min)*: ✍️ Solve `"Number of Islands"` using BFS or DFS.

### Day 49: 🛌 Rest or Catch-up

---

## <span style="color:#B22222">Week 8: 🗺️ Graph Algorithms & Greedy (Phase 3 & 4)</span>

### Day 50: 🌐 Graph Problems
*   **Theory** *(30 min)*: 📚 Review cycle detection in directed and undirected graphs.
*   **Practice** *(60 min)*: ✍️ Solve `"Course Schedule"` (Topological Sort).

### Day 51: 🛣️ Shortest Path: Dijkstra's Algorithm
*   **Theory** *(30 min)*: 📚 Understand Dijkstra's algorithm for finding the shortest path in a weighted graph.
*   **Practice** *(60 min)*: ✍️ Trace the algorithm on paper. Try to implement a basic version.

### Day 52: 🌳 Minimum Spanning Tree (MST)
*   **Theory** *(30 min)*: 📚 Learn the concepts of Prim's and Kruskal's algorithms for finding MSTs.
*   **Practice** *(60 min)*: ✍️ Conceptually trace both algorithms on a sample graph.

### Day 53: 🤑 Greedy Algorithms
*   **Theory** *(30 min)*: 📚 Understand the greedy approach. Study the Activity Selection problem.
*   **Practice** *(60 min)*: ✍️ Solve a greedy problem like `"Assign Cookies"`.

### Day 54: 🤑 Greedy Problems
*   **Theory** *(30 min)*: 📚 Study Fractional Knapsack and Job Scheduling concepts.
*   **Practice** *(60 min)*: ✍️ Solve related problems or implement the logic.

### Day 55: 🎯 Practice & Review
*   **Practice** *(90 min)*: ✍️ Solve 1-2 medium graph problems and 1 greedy problem.

### Day 56: 🛌 Rest or Catch-up

---

## <span style="color:#00008B">Week 9: 🧠 Dynamic Programming (Phase 4)</span>

### Day 57: 💡 Intro to Dynamic Programming
*   **Theory** *(30 min)*: 📚 Understand Optimal Substructure and Overlapping Subproblems. Learn Memoization (top-down) with Fibonacci.
*   **Practice** *(60 min)*: ✍️ Convert the recursive Fibonacci to a memoized version.

### Day 58: 🏗️ DP: Tabulation
*   **Theory** *(30 min)*: 📚 Learn Tabulation (bottom-up) with Fibonacci. Compare with memoization.
*   **Practice** *(60 min)*: ✍️ Solve `"Climbing Stairs"` using tabulation.

### Day 59: 🎒 DP Pattern: Knapsack
*   **Theory** *(30 min)*: 📚 Study the 0/1 Knapsack problem.
*   **Practice** *(60 min)*: ✍️ Solve `"Partition Equal Subset Sum"`.

### Day 60: 📜 DP Pattern: Longest Common Subsequence
*   **Theory** *(30 min)*: 📚 Understand the LCS problem and its recursive + DP solution.
*   **Practice** *(60 min)*: ✍️ Implement the LCS solution.

### Day 61: 📈 DP Pattern: Longest Increasing Subsequence
*   **Theory** *(30 min)*: 📚 Study the LIS problem.
*   **Practice** *(60 min)*: ✍️ Solve `"Longest Increasing Subsequence"`.

### Day 62: 🎯 Practice & Review
*   **Practice** *(90 min)*: ✍️ Re-solve one DP problem from this week without looking at the solution. Try one new medium DP problem.

### Day 63: 🛌 Rest or Catch-up

---

## <span style="color:#FFD700">Week 10: 🚀 Advanced Topics & Full Review (Phase 5)</span>

### Day 64: 📜 String Algorithms (KMP)
*   **Theory** *(30 min)*: 📚 Get a high-level understanding of the KMP algorithm for efficient pattern searching.
*   **Practice** *(60 min)*: ✍️ Solve `"Find the Index of the First Occurrence in a String"`.

### Day 65: 🤝 Disjoint Set Union (DSU)
*   **Theory** *(30 min)*: 📚 Learn the Union-Find data structure with path compression.
*   **Practice** *(60 min)*: ✍️ Use DSU to solve `"Number of Connected Components in an Undirected Graph"`.

### Day 66: 🧐 Review Weakest Area
*   **Practice** *(90 min)*: ✍️ Go back to the topic you struggled with most (e.g., Graphs, DP, Recursion) and re-learn/practice it.

### Day 67: 🧐 Review Weakest Area
*   **Practice** *(90 min)*: ✍️ Continue yesterday's review with more practice problems.

### Day 68: 🎲 Mock Problem Solving
*   **Practice** *(90 min)*: ✍️ Pick 3 random LeetCode problems (1 Easy, 2 Medium) and try to solve them under timed conditions.

### Day 69: 🎲 Mock Problem Solving
*   **Practice** *(90 min)*: ✍️ Pick 3 more random problems and solve them. Focus on explaining your approach out loud.

### Day 70: 🗓️ Plan for the Future
*   **Review** *(90 min)*: ✍️ Look at the "Advanced Topics" in your syllabus. Choose one (e.g., Segment Trees, Advanced Graph Theory) to start exploring next. Plan your next phase of learning.
